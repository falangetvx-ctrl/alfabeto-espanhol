<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alfabeto Espanhol Retro</title>
    <!-- Carrega Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carrega a biblioteca Tone.js para geração de som (simulação retrô) -->
    <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
    <style>
        /* Define a fonte mono para um visual retro e garante que a página ocupe toda a viewport */
        body {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background-color: #1a1a2e; /* Fundo azul escuro (tema espacial/arcade) */
            /* Remove padding/margin padrão para maximizar o uso da tela */
            padding: 0;
            margin: 0;
            /* CORREÇÃO: Removido 'overflow: hidden;' para permitir a rolagem quando o conteúdo for maior que a tela */
            /* Adiciona perspectiva ao corpo para que o starfield se posicione corretamente */
            perspective: 1500px;
        }
        
        /* NOVO: Canvas para o fundo de estrelas 3D */
        #starfield {
            position: fixed; /* Mudei para fixed para garantir que o fundo fique na tela mesmo com a rolagem */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Fundo */
            background-color: transparent; 
            /* Aplica a mesma rotação do grid principal para manter a coerência visual */
            transform: rotateX(10deg) translateZ(-50px);
            /* Importante para garantir a animação suave */
            will-change: transform; 
        }

        /* Estilo do botão/quadrado da letra para o visual retrô */
        .letter-tile {
            position: relative;
            cursor: pointer;
            transition: all 0.1s;
            /* MELHORIA 3D: Sombra maior (8px) e mais escura, mais sombra interna sutil */
            box-shadow: 0 8px 0 0 #050510, /* Sombra principal que simula a profundidade do botão */
                        0 2px 4px rgba(0, 0, 0, 0.4) inset; /* Sombra interna para leve arredondamento */
            border: 4px solid #f6d148; /* Borda amarela forte */
            user-select: none;
            will-change: transform, box-shadow, filter;
            border-radius: 9999px; /* Força o formato circular/arredondado */
            filter: brightness(1.05); /* Levemente mais claro para destacar */
        }

        /* Efeito de clique (pressionar) */
        .letter-tile:active {
            /* Ajusta a translação para o novo tamanho da sombra (8px) */
            transform: translateY(8px); 
            /* Remove a sombra principal ao pressionar, mantendo a interna */
            box-shadow: 0 0px 0 0 #050510, 
                        0 2px 4px rgba(0, 0, 0, 0.4) inset; 
            filter: brightness(0.9); /* Escurece um pouco ao pressionar */
        }

        /* Cores de fundo dos blocos (um ciclo de cores vibrantes) */
        .bg-color-0 { background-color: #ff3366; } /* Vermelho neon */
        .bg-color-1 { background-color: #33ffcc; } /* Ciano neon */
        .bg-color-2 { background-color: #ffcc33; } /* Amarelo neon */
        .bg-color-3 { background-color: #6633ff; } /* Roxo neon */
        .bg-color-4 { background-color: #33ff66; } /* Verde neon */
        .bg-color-5 { background-color: #ff6633; } /* Laranja neon */

        /* Estilo para a fonte principal (letra grande) */
        .letter-display {
            line-height: 1;
            text-shadow: 2px 2px 0 #0f0a1e; /* Sombra de texto pixelada */
        }

        /* Estilo para a exibição da pronúncia (Display de Arcade) */
        #pronunciation-box {
            min-height: 8rem; /* AUMENTADO: Tela de informação maior */
            transition: background-color 0.3s ease-in-out;
            background-color: #111111; /* Preto profundo */
            border: 8px solid #0f0a1e; /* Borda escura externa */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5) inset; /* Sombra interna para profundidade */
            border-radius: 4px; /* Cantos levemente arredondados */
        }

        /* O texto principal do display */
        #current-pronunciation {
            color: #33ff66; /* Verde neon para o texto principal */
            text-shadow: 0 0 5px rgba(51, 255, 102, 0.8); /* Brilho neon sutil */
        }

        .text-glow {
            /* Simula um brilho neon/retro no título */
            text-shadow: 0 0 5px #fff, 0 0 10px #f6d148, 0 0 15px #ff3366;
        }

        /* Container Principal: Adiciona perspectiva para simular a visão de um gabinete de arcade */
        .full-screen-container {
            width: 100%;
            max-width: 100%;
            /* Mudei para min-h-screen, permitindo que cresça além do 100vh se necessário */
            min-height: 100vh; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 1.5rem;
            position: relative; /* Necessário para z-index funcionar */
            z-index: 1; /* Acima do starfield */
        }

        /* Grid de Letras: Aplica rotação e deslocamento para dar o efeito de mesa de arcade inclinada */
        #alphabet-grid {
            width: 100%;
            flex-grow: 1; 
            align-content: flex-start;
            /* Aplica a transformação 3D */
            transform: rotateX(10deg) translateZ(-50px);
            transform-style: preserve-3d;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
    
    <!-- CORREÇÃO: O Starfield agora é position: fixed para evitar que ele role junto com o conteúdo -->
    <canvas id="starfield"></canvas>

    <!-- Container ajustado para tela cheia e perspectiva 3D -->
    <div class="full-screen-container max-w-4xl">
        
        <!-- HEADER (Cenário do Jogo) -->
        <header class="text-center mb-6 w-full">
            <h1 class="text-5xl sm:text-6xl text-white font-extrabold tracking-widest text-glow mb-2">
                ALFABETO ESPAÑOL
            </h1>
            <p class="text-lg sm:text-xl text-yellow-400 font-bold mb-4">
                Clique na letra ou dígrafo e veja como fica seu /som/ (nome) em espanhol.
            </p>
        </header>

        <!-- CAIXA DE PRONÚNCIA (Retro Arcade Display) - AUMENTADA -->
        <div id="pronunciation-box" class="mb-6 p-6 sm:p-10 rounded-lg shadow-inner w-full">
            <p id="current-pronunciation" class="text-3xl sm:text-4xl text-center font-bold tracking-wider">
                INICIAR JOGO
            </p>
            <p class="text-xs sm:text-sm text-gray-400 text-center mt-1">
                Clique em qualquer botão abaixo para começar.
            </p>
        </div>

        <!-- GRID DE LETRAS (COM EFEITO DE INCLINAÇÃO 3D) -->
        <div id="alphabet-grid" class="grid grid-cols-5 sm:grid-cols-6 gap-3 sm:gap-4 pb-4">
            <!-- As letras e dígrafos serão injetados aqui pelo JavaScript -->
        </div>
<!-- RODAPÉ COM LOGO FALANGE CENTRALIZADA -->
<footer class="w-full flex justify-center mt-8 mb-4">
    <img 
        src="Gemini_Generated_Image_hrgq8chrgq8chrgq.png" 
        alt="Falange Educación Lúdica" 
        class="w-52 sm:w-64 drop-shadow-lg"
    >
</footer>

    </div>

    <script type="module">
        // Definição das letras e dígrafos do alfabeto espanhol e suas pronúncias (nomes)
        const alphabet = [
            { letter: 'A', name: '/a/ (A)' },
            { letter: 'B', name: '/be/ (Be)' },
            { letter: 'C', name: '/se/ ou /ke/ (Ce) O "C" só tem som de "S" perto de "E e I"' },
            { letter: 'CH', name: '/tche/ (Che)' }, // Dígrafo adicionado
            { letter: 'D', name: '/de/ (De)' },
            { letter: 'E', name: '/e/ (E)' },
            { letter: 'F', name: '/fe/ (Efe)' },
            { letter: 'G', name: '/re/ ou /gue/ (Ge) O "G" só tem som de "R" perto de "E e I"' },
            { letter: 'H', name: '/sem som/ (Hache)' },
            { letter: 'I', name: '/i/ (I)' },
            { letter: 'J', name: '/re/ (Jota)' },
            { letter: 'K', name: '/ke/ (Ka)' },
            { letter: 'L', name: '/le/ (Ele)' },
            { letter: 'LL', name: '/lhe/ ou /ie/ ou /je/ ou /che/ ou /dje/ ou /tche/ (Elle ou doble ele)' }, // Dígrafo adicionado
            { letter: 'M', name: '/me/ (Eme)' },
            { letter: 'N', name: '/ne/ (Ene)' },
            { letter: 'Ñ', name: '/nhe/ (Eñe)' },
            { letter: 'O', name: '/o/ (o)' },
            { letter: 'P', name: '/pe/ (Pe)' },
            { letter: 'Q', name: '/ke/ (Cu)' },
            { letter: 'R', name: '/RE/ COM VIBRAÇÃO (Erre)' },
            { letter: 'RR', name: '/RE/ COM VIBRAÇÃO FORTE (Erre Forte ou Doble Erre)' }, // Dígrafo adicionado
            { letter: 'S', name: '/se/ (Ese)' },
            { letter: 'T', name: '/Te/ (Te)' },
            { letter: 'U', name: '/u/ (u)' },
            { letter: 'V', name: '/be/ (Uve ou Ve)' },
            { letter: 'W', name: '/u/ ou /be/ (Uve Doble ou Doble Ve)' },
            { letter: 'X', name: '/kse/ ou /re/ (Equis)' },
            { letter: 'Y', name: '/ie/ ou /je/ ou /che/ ou /dje/ ou /tche/ (Ye ou I Griega)' },
            { letter: 'Z', name: '/se/ (Zeta ou Ceta)' },
        ];

        // 1. Configuração do Tone.js para som retrô (Synth simples)
        let synth = null; 
        
        // Função para inicializar o Tone.js e o sintetizador
        const initializeAudio = async () => {
            // O Tone.js precisa ser iniciado por uma interação do usuário
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }
            if (!synth) {
                // Cria um sintetizador com timbre de "jogo retrô" (onda quadrada/square)
                synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "square" }, // Onda quadrada é clássica de jogos 8-bit
                    envelope: {
                        attack: 0.005,
                        decay: 0.1,
                        sustain: 0.01,
                        release: 0.5
                    }
                }).toDestination();
                console.log("Audio Context e Synth inicializados.");
            }
        };


        // 2. Função principal para tocar o som e atualizar a tela
        const playLetter = async (letter, pronunciation, colorIndex) => {
            // Inicializa o áudio na primeira interação do usuário
            await initializeAudio();

            // 2a. Atualiza a pronúncia no display
            const pronunciationBox = document.getElementById('current-pronunciation');
            const boxContainer = document.getElementById('pronunciation-box');

            // Ajuste na exibição para dar destaque aos dígrafos
            const displayLetter = letter.length > 1 ? `DÍGRAFO: ${letter}` : `LETRA: ${letter}`;

            // AUMENTADO: Aumenta o tamanho da fonte para preencher melhor a nova tela de informação
            pronunciationBox.innerHTML = `<span class="text-4xl sm:text-5xl text-yellow-400">#${displayLetter}</span> <span class="text-2xl sm:text-3xl text-green-400"> ${pronunciation}</span>`;
            
            // Adiciona um efeito de flash na caixa de pronúncia
            boxContainer.classList.add('bg-gray-800', 'border-green-500');
            setTimeout(() => {
                boxContainer.classList.remove('bg-gray-800', 'border-green-500');
                boxContainer.classList.add('bg-gray-900');
            }, 150);


            // 2b. Toca o som (Retro Beep)
            const noteMap = {
                'A': 'C4', 'B': 'D4', 'C': 'E4', 'CH': 'F#4',
                'D': 'F4', 'E': 'G4', 'F': 'A4', 'G': 'B4',
                'H': 'C5', 'I': 'D5', 'J': 'E5', 'K': 'F5', 'L': 'G5', 
                'LL': 'A#5', 
                'M': 'A5', 'N': 'B5',
                'Ñ': 'C6', 'O': 'D6', 'P': 'E6', 'Q': 'F6', 'R': 'G6', 
                'RR': 'G#6', 
                'S': 'A6', 'T': 'B6',
                'U': 'C7', 'V': 'D7', 'W': 'E7', 'X': 'F7', 'Y': 'G7', 'Z': 'A7'
            };

            const note = noteMap[letter.toUpperCase()] || 'C4';
            
            // Toca a nota
            if (synth) {
                synth.triggerAttackRelease(note, "8n");
            }
        };

        // 3. Monta o GRID de letras na tela
        const renderGrid = () => {
            const grid = document.getElementById('alphabet-grid');
            grid.innerHTML = ''; // Limpa o grid antes de renderizar
            
            alphabet.forEach((item, index) => {
                const tile = document.createElement('div');
                const colorClass = `bg-color-${index % 6}`; 

                // Mantém o padding p-3 para o tamanho do botão, mas ajusta a fonte
                tile.className = `letter-tile p-3 flex items-center justify-center aspect-square text-white ${colorClass}`;
                
                // REDUZIDO: Letras menores nos botões
                const fontSizeClass = item.letter.length > 1 ? 'text-2xl' : 'text-3xl'; // Letras menores
                
                tile.innerHTML = `<span class="letter-display font-black ${fontSizeClass}">${item.letter}</span>`;
                
                // Adiciona o listener de evento
                tile.addEventListener('click', () => {
                    playLetter(item.letter, item.name, index % 6);
                });

                grid.appendChild(tile);
            });
        };

        /* -------------------------------------------
           4. Lógica do Starfield 3D em Canvas
        ------------------------------------------- */
        
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');
        let width, height;
        const numStars = 500;
        const stars = [];

        // Constantes para simular a velocidade e a perspectiva
        const starSpeed = 0.5;
        const maxStarZ = 500;

        // Função para ajustar o tamanho do canvas ao redimensionar a janela
        const resizeCanvas = () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            // Recria as estrelas para se ajustarem ao novo tamanho (opcional, mas garante boa distribuição)
            stars.length = 0; 
            for (let i = 0; i < numStars; i++) {
                stars.push(createStar());
            }
        };

        // Função para criar uma única estrela
        function createStar() {
            return {
                x: Math.random() * width - width / 2, // Posiciona X no centro
                y: Math.random() * height - height / 2, // Posiciona Y no centro
                z: Math.random() * maxStarZ, // Profundidade Z (quanto menor, mais perto)
                ox: 0, // Posição X antiga
                oy: 0, // Posição Y antiga
            };
        }

        // Loop principal de animação
        function animateStarfield() {
            // Limpa o frame anterior. Usamos uma cor transparente, pois o fundo está no body
            ctx.clearRect(0, 0, width, height);

            // Move o ponto de origem para o centro do canvas para simular perspectiva
            ctx.save();
            ctx.translate(width / 2, height / 2);
            
            for (let star of stars) {
                // 1. Atualiza a profundidade (Z) para simular o movimento para frente
                star.z -= starSpeed;

                // 2. Se a estrela passou (z <= 0), reposiciona-a no fundo
                if (star.z <= 0) {
                    star.x = Math.random() * width - width / 2;
                    star.y = Math.random() * height - height / 2;
                    star.z = maxStarZ;
                    star.ox = 0;
                    star.oy = 0;
                }

                // 3. Projeção 3D (X e Y na tela com base em Z)
                const perspective = maxStarZ / star.z;
                const projectedX = star.x * perspective;
                const projectedY = star.y * perspective;
                
                // 4. Desenha a estrela
                // O tamanho do raio e o brilho dependem da profundidade (Z)
                const radius = Math.max(0.5, 1.5 - (star.z / maxStarZ)); 
                
                ctx.beginPath();
                ctx.arc(projectedX, projectedY, radius, 0, Math.PI * 2);
                
                // Estrelas mais próximas são mais brilhantes (brancas)
                const brightness = Math.floor(255 - (star.z / maxStarZ) * 200); 
                ctx.fillStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                ctx.fill();

                // 5. Adiciona o rastro (efeito de velocidade)
                if (star.ox && star.oy) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - (star.z / maxStarZ)})`;
                    ctx.lineWidth = radius * 1.5;
                    ctx.beginPath();
                    // Desenha a linha da posição anterior até a atual
                    ctx.moveTo(projectedX, projectedY);
                    // Projeta a posição anterior também para garantir que o rastro siga a perspectiva
                    const projectedOX = star.ox * (maxStarZ / star.oz);
                    const projectedOY = star.oy * (maxStarZ / star.oz);
                    ctx.lineTo(projectedOX, projectedOY);
                    ctx.stroke();
                }

                // 6. Salva a posição atual para o rastro do próximo frame
                star.ox = star.x;
                star.oy = star.y;
                star.oz = star.z;
            }

            ctx.restore();
            requestAnimationFrame(animateStarfield);
        }

        // 5. Início da Aplicação (Corrigido para usar window.onload)
        window.onload = function () {
            // 3. Monta o GRID de letras na tela
            renderGrid();
            
            // Adiciona a instrução para iniciar o áudio no primeiro clique
            document.body.addEventListener('click', initializeAudio, { once: true });
            
            // Inicializa o starfield (o canvas precisa ter tamanho definido)
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); 
            animateStarfield();
        };

    </script>
</body>
</html>